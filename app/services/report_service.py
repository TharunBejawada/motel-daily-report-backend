import re
import uuid
from datetime import datetime
from typing import List, Dict, Any, Optional

from app.utils.gmail_client import fetch_all_emails, fetch_recent_emails
from app.utils.whitelist_manager import is_whitelisted
from app.parsers.pdf_text import extract_text_from_pdf
from app.parsers.docx_text import extract_text_from_docx
from app.parsers.openai_parser import OpenAIReportParser

from app.vectorstore.pinecone_client import upsert_report_embedding

from app.repositories.session import get_session
from app.db.models import (
    MotelMaster,
    ReportMaster,
    ReportVacantDirtyRoom,
    ReportOutOfOrderRoom,
    ReportCompRoom,
    ReportIncident,
)

DATE_RX = re.compile(r"(\d{2}[-/]\d{2}[-/]\d{2,4})")


def _normalize_date(s: str | None) -> Optional[datetime.date]:
    if not s:
        return None
    s = s.strip()
    for fmt in ("%Y-%m-%d", "%d-%m-%Y", "%m-%d-%Y", "%d/%m/%Y", "%m/%d/%Y", "%d-%m-%y", "%m-%d-%y", "%d/%m/%y", "%m/%d/%y"):
        try:
            return datetime.strptime(s, fmt).date()
        except Exception:
            continue
    m = re.search(r"\b(\d{2})[.\-/](\d{2})[.\-/](\d{2,4})\b", s)
    if m:
        d, mth, y = m.group(1), m.group(2), m.group(3)
        if len(y) == 2:
            y = f"20{y}"
        try:
            return datetime.strptime(f"{y}-{mth}-{d}", "%Y-%m-%d").date()
        except Exception:
            pass
    return None


def _first_nonempty(*vals):
    for v in vals:
        if v:
            return v
    return None


# def _split_property(property_name: str) -> tuple[str, Optional[str]]:
#     """Split 'Monticello Inn, Framingham' ‚Üí ('Monticello Inn', 'Framingham')."""
#     parts = [p.strip() for p in property_name.split(",")]
#     motel = parts[0] if parts else property_name.strip()
#     location = parts[1] if len(parts) > 1 else None
#     return motel, location


def _split_property(property_name: str):
    """Split property_name into motel_name and location if comma-separated."""
    parts = [p.strip() for p in (property_name or "").split(",")]
    motel_name = parts[0] if parts else property_name
    location = parts[1] if len(parts) > 1 else None
    return motel_name, location


def _ensure_motel(db, property_name: str) -> MotelMaster:
    """
    Ensures a motel record exists. If not, creates one.
    Uses auto-increment integer primary key instead of UUID.
    """
    motel_name, location = _split_property(property_name)

    # ‚úÖ Search by motel_name and location (instead of UUID)
    query = db.query(MotelMaster).filter(MotelMaster.motel_name == motel_name)
    if location:
        query = query.filter(MotelMaster.location == location)

    m = query.first()
    if m:
        return m

    # ‚úÖ Create new motel entry (id is auto-generated by DB)
    m = MotelMaster(
        motel_name=motel_name,
        location=location
    )
    db.add(m)
    db.flush()  # ensures m.id is available immediately
    return m


def _insert_children(db, report_id: int, parsed: dict):
    for item in parsed.get("vacant_dirty_rooms") or []:
        db.add(
            ReportVacantDirtyRoom(
                report_id=report_id,
                room_number=str(item.get("room_number") or "").strip(),
                reason=(item.get("reason") or None),
                days=int(item.get("days") or 0),
                action=(item.get("action") or None),
            )
        )
    for item in parsed.get("out_of_order_rooms") or []:
        db.add(
            ReportOutOfOrderRoom(
                report_id=report_id,
                room_number=str(item.get("room_number") or "").strip(),
                reason=(item.get("reason") or None),
                days=int(item.get("days") or 0),
                action=(item.get("action") or None),
            )
        )
    for item in parsed.get("comp_rooms") or []:
        db.add(
            ReportCompRoom(
                report_id=report_id,
                room_number=str(item.get("room_number") or "").strip(),
                notes=(item.get("notes") or None),
            )
        )
    for item in parsed.get("incidents") or []:
        desc = item.get("description") or None
        if desc:
            db.add(ReportIncident(report_id=report_id, description=desc))


def parse_report_text(text: str) -> dict:
    lines = [ln.strip() for ln in text.splitlines() if ln.strip()]
    prop = None
    for ln in lines[:5]:
        if "inn" in ln.lower() or "hotel" in ln.lower() or "motel" in ln.lower():
            prop = ln
            break
    date_str = None
    m = DATE_RX.search(text)
    if m:
        date_str = m.group(1)

    rough = {
        "property_name": prop,
        "report_date": date_str,
        "department": None,
        "auditor": None,
        "revenue": None,
        "adr": None,
        "occupancy": None,
        "vacant_clean": None,
        "vacant_dirty": None,
        "out_of_order_rooms_storage": None,
        "vacant_dirty_rooms": [],
        "out_of_order_rooms": [],
        "comp_rooms": [],
        "incidents": [],
    }

    ai = OpenAIReportParser().parse(text, metadata=None) or {}
    parsed = {
        "property_name": _first_nonempty(ai.get("property_name"), rough["property_name"]),
        "report_date": _first_nonempty(ai.get("report_date"), rough["report_date"]),
        "department": ai.get("department"),
        "auditor": ai.get("auditor"),
        "revenue": ai.get("revenue"),
        "adr": ai.get("adr"),
        "occupancy": ai.get("occupancy"),
        "vacant_clean": ai.get("vacant_clean"),
        "vacant_dirty": ai.get("vacant_dirty"),
        "out_of_order_rooms_storage": ai.get("out_of_order_rooms_storage"),
        "vacant_dirty_rooms": ai.get("vacant_dirty_rooms") or [],
        "out_of_order_rooms": ai.get("out_of_order_rooms") or [],
        "comp_rooms": ai.get("comp_rooms") or [],
        "incidents": ai.get("incidents") or [],
    }
    return parsed


def ingest_reports_from_gmail(
    mode: str = "recent",
    limit: int = 5,
    pages: int | None = None,
    after: str | None = None,
    before: str | None = None,
) -> Dict[str, Any]:
    q_parts = ["has:attachment"]
    if after:
        q_parts.append(f"after:{after}")
    if before:
        q_parts.append(f"before:{before}")
    gmail_query = " ".join(q_parts)

    emails = (
        fetch_recent_emails(limit, gmail_query)
        if mode == "recent"
        else fetch_all_emails(pages, gmail_query)
    )

    stored = 0
    skipped = 0
    items: List[Dict[str, Any]] = []

    for email in emails:
        attachments = email.get("attachments") or []
        if not attachments:
            print(f"‚ö†Ô∏è No attachments found in email: {email['subject']}")
            continue

        for att in attachments:
            fn = (att.get("filename") or "").lower()
            print(f"üìé Processing attachment: {fn}")
            if not (fn.endswith(".pdf") or fn.endswith(".docx")):
                print(f"‚è© Skipping non-report file: {fn}")
                continue

            pdf_bytes = att.get("data")
            if not pdf_bytes:
                print(f"‚ö†Ô∏è Empty data for attachment: {fn}")
                continue

            if fn.endswith(".pdf"):
                text = extract_text_from_pdf(pdf_bytes)
                print(f"üìÑ DEBUG: Extracted text length from {fn}: {len(text) if text else 0}")
            else:
                text = extract_text_from_docx(pdf_bytes)

            if not text:
                print(f"‚ö†Ô∏è Skipping {fn} because no text was extracted")
                continue

            parsed = parse_report_text(text)
            property_name = parsed.get("property_name") or (email.get("subject") or "").strip() or "Unknown Property"
            report_dt = _normalize_date(parsed.get("report_date") or "") or datetime.utcnow().date()

            with get_session() as db:
                motel = _ensure_motel(db, property_name)

                existing = (
                    db.query(ReportMaster)
                    .filter(ReportMaster.motel_id == motel.id)
                    .filter(ReportMaster.report_date == report_dt)
                    .first()
                )
                if existing:
                    skipped += 1
                    items.append(
                        {
                            "file": fn,
                            "motel": motel.motel_name,
                            "report_date": str(report_dt),
                            "status": "duplicate",
                            "id": existing.id,
                        }
                    )
                    continue

                master = ReportMaster(
                    motel_id=motel.id,
                    property_name=motel.motel_name,
                    report_date=report_dt,
                    department=parsed.get("department"),
                    auditor=parsed.get("auditor"),
                    revenue=float(parsed.get("revenue")) if parsed.get("revenue") not in (None, "") else 0.0,
                    adr=float(parsed.get("adr")) if parsed.get("adr") not in (None, "") else 0.0,
                    occupancy=int(parsed.get("occupancy")) if parsed.get("occupancy") not in (None, "") else 0,
                    vacant_clean=int(parsed.get("vacant_clean")) if parsed.get("vacant_clean") not in (None, "") else 0,
                    vacant_dirty=int(parsed.get("vacant_dirty")) if parsed.get("vacant_dirty") not in (None, "") else 0,
                    out_of_order_storage_rooms=int(parsed.get("out_of_order_rooms_storage")) if parsed.get("out_of_order_rooms_storage") not in (None, "") else 0,
                    created_at=datetime.utcnow()
                )
                db.add(master)
                db.flush()

                _insert_children(db, master.id, parsed)
                db.commit()

                # Prepare text to embed
                text_for_embedding = f"""
                Motel: {motel.motel_name}
                Report Date: {master.report_date}
                Location: {motel.location}
                Department: {master.department}
                Auditor: {master.auditor}
                Revenue: {master.revenue}
                ADR: {master.adr}
                Occupancy: {master.occupancy}
                Vacant Clean: {master.vacant_clean}
                Vacant Dirty: {master.vacant_dirty}
                Out Of Order/Storage rooms: {master.out_of_order_storage_rooms}
                Complimentary Rooms: {master.comp_room_records}
                Incidents: {master.incident_records}
                Vacant/Dirty Rooms: {master.vacant_dirty_rooms}
                Out Of Order Rooms: {master.out_of_order_rooms}
                """

                # Create metadata to store with the vector
                metadata = {
                    "motel_name": motel.motel_name,
                    "location": motel.location,
                    "department": master.department or "",
                    "auditor": master.auditor or "",
                    "content": text_for_embedding[:4000]
                }

                # üî• Generate and insert vector into Pinecone
                upsert_report_embedding(motel.id, text_for_embedding, metadata)

                stored += 1
                items.append(
                    {
                        "file": fn,
                        "motel": motel.motel_name,
                        "motel_id": motel.id,
                        "location": motel.location,
                        "report_date": str(report_dt),
                        "status": "stored",
                        "id": master.id,
                    }
                )

    print(f"‚úÖ Stored: {stored} | ‚è© Skipped: {skipped}")
    return {"stored": stored, "skipped": skipped, "items": items}
